const y=new Set;function M(){const e=[],s="div._4k8w";return document.querySelectorAll(s).forEach((r,a)=>{let i="Unknown Sender",l="",u=!1,n=`new-convo-${a}-${Date.now()}`;try{const f=r.querySelector(".xmi5d70");if(!f)return;i=f.textContent.trim();const C=f.classList.contains("x117nqv4"),x=f.classList.contains("x1fcty0u");if(u=C&&!x,!u)return;const I=r.querySelector("div._4k8y ._4ik4._4ik5");if(!I||(l=I.textContent.trim(),l.toLowerCase().startsWith("you:")))return;const S=r.querySelector("div._a6ag._a6ah");let E=!1;if(S){let c=S;for(let w=0;w<5;w++){if(c.dataset.testid&&c.dataset.testid.includes("thread")){n=c.dataset.testid,console.log(`Content.js: Found stable conversation ID from data-testid: ${n}`),E=!0;break}if(c.href&&c.href.includes("thread_id="))try{const g=c.href.match(/thread_id=([^&]+)/);if(g&&g[1]){n=`thread-${g[1]}`,console.log(`Content.js: Found stable conversation ID from href: ${n}`),E=!0;break}}catch(g){console.log("Content.js: Error extracting thread ID from href:",g)}if(!c.parentElement)break;c=c.parentElement}}if(!E){let c=function(w){let g=0;for(let j=0;j<w.length;j++)g=(g<<5)-g+w.charCodeAt(j),g|=0;return Math.abs(g).toString().substring(0,6)};var o=c;n=`c${c(i)}`,console.log(`Content.js: Using short unique ID: ${n} for sender: ${i}`)}if(l){const c=`${n}:${l.slice(0,50)}`;r.setAttribute("data-chatgpt-conversation-id",n),e.push({id:`q-${n}`,text:l,sender:i,conversationId:n,previewElement:r}),console.log(`Content.js: Conv index ${a}, Sender "${i}": Successfully extracted UNREAD question: "${l}" (Conv ID: ${n}). Added to processing queue.`),r.classList.add("chatgpt-pending-response"),r.setAttribute("data-chatgpt-processing-time",Date.now().toString())}else console.log(`Content.js: Conv index ${a}, Sender "${i}": Message text was effectively empty before pushing to questions array, skipping.`)}catch(f){console.error("Content.js: Error processing a conversation:",f,r)}}),e.length===0&&console.log("Content.js: No new, unread messages."),e}const L=`
  position: fixed;
  bottom: 60px;
  right: 60px;
  background-color: #0084ff;
  color: white;
  border: none;
  border-radius: 4px;
  padding: 8px 16px;
  font-size: 14px;
  font-weight: bold;
  cursor: pointer;
  z-index: 9999;
  box-shadow: 0px 2px 5px rgba(0, 0, 0, 0.2);
`;function O(e,s=5e3){return new Promise(t=>{let a=0;const i=setInterval(()=>{const l=document.querySelector(e);l&&(clearInterval(i),t(l)),a+=100,a>=s&&(clearInterval(i),console.warn(`Content.js: waitForElementOnPage timed out for selector: ${e}`),t(null))},100)})}const D=5e3;let p=null,b=!0,k=!1,h=null;async function v(){if(h){console.log(`Content.js: Automation cycle paused. Waiting to deliver response for Conv ID: ${h.conversationId} (Sender: ${h.sender}, Original Q: "${h.originalQuestionText}"). Not scanning for new messages now.`);return}if(k){console.log("Content.js: Automation cycle paused. A delivery attempt is already in progress (isAttemptingDelivery is true). Not scanning for new messages now.");return}const e=await chrome.runtime.sendMessage({action:"getSettings"});if(chrome.runtime.lastError){console.error("Content.js: Error getting settings in runAutomationCycle:",chrome.runtime.lastError.message);return}if(window.isPartialAutomationEnabled=e.isPartialAutomation===!0,window.isPartialAutomationEnabled&&console.log("Content.js: Partial Automation mode enabled. Responses will be placed in input box but not sent automatically."),window.isPartialAutomationEnabled&&!b){console.log("Content.js: Skipping conversation scanning because isPartialChecking is false while in Partial Automation mode.");return}else window.isPartialAutomationEnabled||(b=!0);if(e&&e.isEnabled){const s=M();s.length>0?await R(s):y.size>0}}function T(){console.log("Content.js: Clearing visual markers from processed conversations"),document.querySelectorAll(".chatgpt-pending-response").forEach(s=>{console.log("Content.js: Clearing visual pending marker from element:",s.getAttribute("data-chatgpt-conversation-id")),s.classList.remove("chatgpt-pending-response")})}function A(){console.log("Content.js: Attempting to start automation with new logic..."),p&&(clearInterval(p),p=null),b=!0,console.log("Content.js: Reset isPartialChecking to true during automation start."),T(),U(),v(),p=setInterval(v,D),console.log(`Content.js: Polling interval started with ID ${p} for every ${D}ms.`),console.log("Content.js: Relying solely on polling interval for message scanning.")}function P(){console.log("Content.js: Stopping automation."),p&&(clearInterval(p),console.log(`Content.js: Polling interval ${p} stopped.`),p=null),h=null,k=!1}function U(){const e=document.getElementById("meta-suite-next-button");e&&e.remove();const s=document.createElement("button");s.id="meta-suite-next-button",s.textContent="Next",s.style.cssText=L,s.addEventListener("click",()=>{b=!0,console.log("Content.js: Next button clicked. Set isPartialChecking to true."),T(),h&&(console.log(`Content.js: Clearing current response delivery for ${h.conversationId} to allow fresh scanning.`),h=null),k=!1,setTimeout(v,500),s.textContent="Scanning...",setTimeout(()=>{s.textContent="Next"},1500)}),document.body.appendChild(s),console.log("Content.js: Added 'Next' button to the page.")}let d=null,m=!1;const $=2;async function R(e){if(e.length!==0){console.log(`Content.js: Processing ${e.length} questions with delay between each`);for(let s=0;s<e.length;s++){const t=e[s];s>0&&await new Promise(a=>setTimeout(a,15e3));let r;t.conversationId&&!t.conversationId.startsWith("new-convo-")?r=t.conversationId+"||"+t.text:r=t.sender+"||"+t.text;try{if(y.has(r)){console.log(`Content.js: Skipping question for ${t.conversationId} as it previously resulted in "NOTFOUND": "${t.text}"`),t.previewElement&&t.previewElement.classList.contains("chatgpt-pending-response")&&t.previewElement.classList.remove("chatgpt-pending-response");continue}console.log(`Content.js: Sending question to background: "${t.text}" (Sender: ${t.sender}, Conv ID: ${t.conversationId})`),t.previewElement&&(t.previewElement.classList.add("chatgpt-pending-response"),console.log(`Content.js: Marked conversation ${t.conversationId} as 'chatgpt-pending-response'.`));const a=await chrome.runtime.sendMessage({action:"getSettings"});if(chrome.runtime.lastError){console.error("Content.js: Error getting settings in sendQuestionsToBackground:",chrome.runtime.lastError.message),t.previewElement&&t.previewElement.classList.remove("chatgpt-pending-response");continue}const i=`Customer-id-${t.conversationId}
Question: `,l=Date.now().toString().slice(-6),u=i+t.text,n=await chrome.runtime.sendMessage({action:"getAnswerFromChatGPT",question:u,conversationId:t.conversationId,requestId:l});if(chrome.runtime.lastError){console.error("Content.js: Error sending message to background (getAnswerFromChatGPT):",chrome.runtime.lastError.message),t.previewElement&&(t.previewElement.classList.remove("chatgpt-pending-response"),console.log(`Content.js: Unmarked conversation ${t.conversationId} from 'chatgpt-pending-response' due to send error.`));continue}if(n&&n.answer){if(console.log(`Content.js: Received answer for ${t.conversationId}: "${n.answer}"`),n.answer==="NOTFOUND"){console.log(`Content.js: Response for ${t.conversationId} (key: "${r}") is "NOTFOUND". Adding to ignore list and skipping delivery.`),console.log(`Content.js: Adding key "${r}" to notFoundMessages. Current size before add: ${y.size}`),y.add(r),t.previewElement&&(t.previewElement.classList.remove("chatgpt-pending-response"),console.log(`Content.js: Unmarked ${t.conversationId} from pending due to "NOTFOUND".`)),d=null,m=!1;continue}t.previewElement&&(t.previewElement.classList.remove("chatgpt-pending-response"),console.log(`Content.js: Unmarked ${t.conversationId} from pending, preparing for delivery.`)),d={conversationId:t.conversationId,sender:t.sender,originalQuestionText:t.text,answer:n.answer,originalPreviewElement:t.previewElement,retries:0},console.log(`Content.js: Staging response for delivery. Conv ID: ${d.conversationId}, Sender: ${d.sender}, Original Q: "${d.originalQuestionText}", Answer: "${d.answer}"`),q();break}else n&&n.error?(console.error(`Content.js: Error from background for question "${t.text}":`,n.error),t.previewElement&&(t.previewElement.classList.remove("chatgpt-pending-response"),console.log(`Content.js: Unmarked conversation ${t.conversationId} from 'chatgpt-pending-response' due to ChatGPT error: ${n.error}`))):(console.log(`Content.js: No valid answer or error received from background for: "${t.text}"`),t.previewElement&&(t.previewElement.classList.remove("chatgpt-pending-response"),console.log(`Content.js: Unmarked conversation ${t.conversationId} from 'chatgpt-pending-response' due to no answer/error.`)))}catch(a){if(console.error(`Content.js: Error in sendQuestionsToBackground loop for question "${t.text}":`,a),a.message&&a.message.includes("Receiving end does not exist")){console.warn("Content.js: Extension context invalidated. Please reload the page.");break}}}}}async function q(){var r,a;if(!d){m=!1;return}if(m)return;m=!0;const e=d,s=e.originalQuestionText.length>30?`${e.originalQuestionText.substring(0,30)}...`:e.originalQuestionText;console.log(`Content.js: Initiating delivery attempt #${e.retries+1} for conversation ${e.conversationId} (Sender: ${e.sender}, Original Q: "${s}")`);let t=!1;try{const i=((r=e.originalPreviewElement)==null?void 0:r.querySelector("div._a6ag._a6ah"))||e.originalPreviewElement;let l=!1;if(!i||!document.body.contains(i)){console.warn(`Content.js: Delivery - Conversation preview element for ID ${e.conversationId} (Sender: ${e.sender}) is NOT FOUND or STALE. Aborting delivery for this response.`),e.retries=$,d=null,m=!1,setTimeout(v,500);return}else{console.log(`Content.js: Delivery - Attempting to click conversation preview for Conv ID: ${e.conversationId}, Sender: ${e.sender}:`,i);try{console.log(`Content.js: Clicking on conversation element for ${e.conversationId}...`),i.click(),await new Promise(o=>setTimeout(o,2e3));const u="div[role='main'] span.x1lliihq.x1plvlek.xryxfnj.x1n2onr6.x193iq5w.xeeoieq.x1fj2vde.x100vrsf.x1jchvi3.x1fcty0u.x132q4wb.x13fuv20.xu3j5b3.x1q0q8m5.x26u7qi.x972fbf.xcfux6l.x1qhh985.xm0m39n.x9f619.x1s65kcs.x1ypdohk.x78zum5.x1i64zmx.x1rdy4ex.x17w43d7.x1ye3gou.xt62z39.x1x521is.x16tdsg8.x1hl2dhg.xggy1nq.x1ja2u2z.x1t137rt.x1q0g3np.x87ps6o.x1lku1pv.x1a2a7pz.x6s0dn4.x10wh9bi.x1wdrske.x8du52y.x17z4h18",n=document.querySelector(u);if(n){const o=n.textContent.trim();if(console.log(`Content.js: Delivery - Post-click: Intended sender: "${e.sender}", Active chat sender found in UI: "${o}"`),o!==(e==null?void 0:e.sender)){console.error(`Content.js: Delivery - CRITICAL MISMATCH! Clicked on preview for "${e.sender}" but active chat is with "${o}".`),console.error("Content.js: Delivery - Aborting to prevent sending response to the wrong person!"),d=null,m=!1,setTimeout(v,500);return}}else console.warn(`Content.js: Delivery - Post-click: Could not identify active chat sender name in UI to verify target for "${e.sender}".`);try{const o=document.querySelectorAll('div[role="row"]');if(o&&o.length>0){const C=!o[o.length-1].querySelector('div[data-author-is-self="true"]');if(console.log(`Content.js: Delivery - Last message appears to be from ${C?"customer":"us/page"}`),C)console.log("Content.js: Delivery - Last message is from customer, proceeding with delivery.");else{console.warn("Content.js: Delivery - Aborting response as the last message is not from the customer but from us/page."),e.retries=$,d=null,m=!1,setTimeout(v,500);return}}else console.warn("Content.js: Delivery - Could not find message containers to check last message sender.")}catch(o){console.error("Content.js: Delivery - Error checking last message sender:",o)}l=!0}catch(u){console.error("Content.js: Delivery - Click failed:",u,i)}}if(l){const u='textarea[placeholder="Reply in Messengerâ€¦"]';let n=await O(u,7e3);if(!n){const o='div[aria-label*="Message"][role="textbox"], textarea[placeholder*="Message"], div[data-lexical-editor="true"]';console.warn(`Content.js: Delivery - Specific input '${u}' not found. Trying fallback: ${o}`),n=document.querySelector(o)}if(n){n.focus(),n.value="",n.dispatchEvent(new Event("input",{bubbles:!0,composed:!0})),n.value=e.answer,n.dispatchEvent(new Event("input",{bubbles:!0,composed:!0})),n.dispatchEvent(new Event("change",{bubbles:!0,composed:!0})),console.log(`Content.js: Delivery - Set text in input field for ${e.conversationId}.`);let o=null;const f=['button[aria-label="Send"]','button[data-testid="messenger_send_button"]','button[aria-label*="Send message"]','div[aria-label="Send"][role="button"]'];for(const C of f){let x=n.closest('div[role="complementary"], div[role="form"], div[class*="chat"], div[class*="composer"]')||((a=n.parentElement)==null?void 0:a.parentElement);if(x&&(o=x.querySelector(C)),o||(o=document.querySelector(C),o))break}o&&!o.disabled?window.isPartialAutomationEnabled?(console.log("Content.js: Delivery - Partial Automation mode - NOT clicking send button. Message ready for manual review and sending."),isPartialChecking=!1,console.log("Content.js: Set isPartialChecking to false because message was added as draft."),addNextButton(),t=!0):(console.log("Content.js: Delivery - Send button found and enabled. Clicking.",o),o.click(),isPartialChecking=!0,t=!0):o!=null&&o.disabled?console.warn("Content.js: Delivery - Send button found but is DISABLED."):console.warn("Content.js: Delivery - Send button NOT FOUND.")}else console.warn(`Content.js: Delivery - Message input field not found for ${e.conversationId}.`)}else console.warn(`Content.js: Delivery - Skipping input/send because click on conversation preview failed or element not found for ${e.conversationId}.`)}catch(i){console.error("Content.js: Delivery - Error during delivery attempt:",i),t=!1}t?(console.log(`Content.js: Successfully delivered response to ${e.conversationId}.`),e.originalPreviewElement&&(e.originalPreviewElement.classList.add("chatgpt-processed"),console.log(`Content.js: Marked conversation ${e.conversationId} as 'chatgpt-processed'.`)),d=null,m=!1,setTimeout(v,500)):(console.warn(`Content.js: Delivery attempt #${e.retries+1} failed for ${e.conversationId}.`),e.retries++,e.retries<$?(console.log(`Content.js: Scheduling retry for ${e.conversationId}.`),m=!1,setTimeout(q,5e3)):(console.error(`Content.js: Max retries reached for ${e.conversationId}. Giving up on this response.`),d=null,m=!1,setTimeout(v,500)))}console.log("Meta Suite ChatGPT Bridge content script loaded.");async function N(){const e=await chrome.runtime.sendMessage({action:"getSettings"});if(chrome.runtime.lastError){console.error("Content.js: Error getting settings for initial automation setup:",chrome.runtime.lastError.message);return}e&&e.isEnabled?A():console.log("Content.js: Initial settings indicate automation is disabled.")}N();chrome.storage.onChanged.addListener((e,s)=>{s==="sync"&&e.isEnabled!==void 0&&(console.log("Content.js: isEnabled setting changed to",e.isEnabled.newValue),e.isEnabled.newValue?A():P())});chrome.runtime.onMessage.addListener((e,s,t)=>e.action==="settingsUpdated"?(console.log("Content.js: Notified of settings update. Re-evaluating automation cycle."),chrome.runtime.sendMessage({action:"getSettings"},r=>{r!=null&&r.isPartialAutomation||(isPartialChecking=!0,console.log("Content.js: Partial automation disabled, reset isPartialChecking to true")),P(),N()}),t({status:"Settings acknowledged by content script"}),!0):(console.log("Content.js: Received unhandled message action:",e.action),!1));
